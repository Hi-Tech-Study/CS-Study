<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul.nav-list:first-child > li:not(:nth-child(26)) > a, .site-nav > ul.nav-list:first-child > li > ul > li a { background-image: none; } .site-nav > ul.nav-list:not(:first-child) a, .site-nav li.external a { background-image: none; } .site-nav > ul.nav-list:first-child > li:nth-child(26) > a { font-weight: 600; text-decoration: none; }.site-nav > ul.nav-list:first-child > li:nth-child(26) > button svg { transform: rotate(-90deg); }.site-nav > ul.nav-list:first-child > li.nav-list-item:nth-child(26) > ul.nav-list { display: block; } </style> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Query Optimization(Slow Query Tuning) | Dev Open Library</title> <meta name="generator" content="Jekyll v3.10.0" /> <meta property="og:title" content="Query Optimization(Slow Query Tuning)" /> <meta property="og:locale" content="en" /> <meta name="description" content="A minimal, responsive and feature-rich Jekyll theme for technical writing." /> <meta property="og:description" content="A minimal, responsive and feature-rich Jekyll theme for technical writing." /> <link rel="canonical" href="http://localhost:4000/Database/db_query_optimization.html" /> <meta property="og:url" content="http://localhost:4000/Database/db_query_optimization.html" /> <meta property="og:site_name" content="Dev Open Library" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Query Optimization(Slow Query Tuning)" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"A minimal, responsive and feature-rich Jekyll theme for technical writing.","headline":"Query Optimization(Slow Query Tuning)","url":"http://localhost:4000/Database/db_query_optimization.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/" class="site-title lh-tight"> Dev Open Library </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link">CS Study Notes</a></li><li class="nav-list-item"><a href="/Network/network_cors.html" class="nav-list-link">CORS</a></li><li class="nav-list-item"><a href="/OS/os_cpu_scheduling.html" class="nav-list-link">CPU Scheduling</a></li><li class="nav-list-item"><a href="/OS/os_com_and_operating_system.html" class="nav-list-link">Computer 구조</a></li><li class="nav-list-item"><a href="/Database/db_cache.html" class="nav-list-link">DB 캐싱</a></li><li class="nav-list-item"><a href="/Algorithm/ag_dfs_bfs.html" class="nav-list-link">DFS와 BFS</a></li><li class="nav-list-item"><a href="/Algorithm/ag_dp.html" class="nav-list-link">DP (Dynamic Programming)</a></li><li class="nav-list-item"><a href="/OS/os_deadlock.html" class="nav-list-link">Deadlock이란?</a></li><li class="nav-list-item"><a href="/Network/network_dns.html" class="nav-list-link">Domain</a></li><li class="nav-list-item"><a href="/Design%20Pattern/dp_factory_pattern.html" class="nav-list-link">Factory Pattern</a></li><li class="nav-list-item"><a href="/Algorithm/ag_gcd_lcm.html" class="nav-list-link">GCD(Greatest Common Divisor) 알고리즘</a></li><li class="nav-list-item"><a href="/Network/network_http_https.html" class="nav-list-link">HTTP (Hyper Text Transfer Protocol)</a></li><li class="nav-list-item"><a href="/Network/network_http_message.html" class="nav-list-link">HTTP 메시지</a></li><li class="nav-list-item"><a href="/Network/network_ip.html" class="nav-list-link">IP의 정의와 역할</a></li><li class="nav-list-item"><a href="/Database/db_index.html" class="nav-list-link">Index? 그게뭔데!</a></li><li class="nav-list-item"><a href="/Design%20Pattern/dp_iterator_pattern.html" class="nav-list-link">Iterator pattern</a></li><li class="nav-list-item"><a href="/Design%20Pattern/dp_mvc_pattern.html" class="nav-list-link">MVC 패턴</a></li><li class="nav-list-item"><a href="/Design%20Pattern/dp_mvp_pattern.html" class="nav-list-link">MVP Architecture Pattern</a></li><li class="nav-list-item"><a href="/Design%20Pattern/dp_mvvm_pattern.html" class="nav-list-link">MVVM 패턴 정의</a></li><li class="nav-list-item"><a href="/Data%20Structure/ds_map.html" class="nav-list-link">Map</a></li><li class="nav-list-item"><a href="/OS/os_memory.html" class="nav-list-link">Memory</a></li><li class="nav-list-item"><a href="/OS/os_multi_processing.html" class="nav-list-link">Multi Process (멀티 프로세스)</a></li><li class="nav-list-item"><a href="/Network/network_devices.html" class="nav-list-link">Network Device</a></li><li class="nav-list-item"><a href="/Network/network_osi_tcpip.html" class="nav-list-link">OSI 7계층 &amp; TCP/IP 4계층</a></li><li class="nav-list-item"><a href="/OS/os_pcb_and_context_switch.html" class="nav-list-link">PCB와 Context Switching</a></li><li class="nav-list-item"><a href="/Database/db_query_optimization.html" class="nav-list-link">Query Optimization(Slow Query Tuning)</a></li><li class="nav-list-item"><a href="/Algorithm/ag_quick_sort.html" class="nav-list-link">Quick Sort</a></li><li class="nav-list-item"><a href="/Data%20Structure/ds_set.html" class="nav-list-link">Set</a></li><li class="nav-list-item"><a href="/OS/os_Blocking_Non-Blocking_Synchronous_Asynchronous.html" class="nav-list-link">Synchronous?</a></li><li class="nav-list-item"><a href="/Network/network_tcp.html" class="nav-list-link">TCP</a></li><li class="nav-list-item"><a href="/OS/os_thread.html" class="nav-list-link">Thread</a></li><li class="nav-list-item"><a href="/Network/network_udp.html" class="nav-list-link">UDP (User Datagram Protocol)</a></li><li class="nav-list-item"><a href="/OS/os_mutex_semaphore.html" class="nav-list-link">공유 자원 &amp; 임계 영역(Semaphore &amp; Mutex)</a></li><li class="nav-list-item"><a href="/Algorithm/ag_implementation.html" class="nav-list-link">구현(Implementation)</a></li><li class="nav-list-item"><a href="/Algorithm/ag_greedy.html" class="nav-list-link">그리디 (Greedy)</a></li><li class="nav-list-item"><a href="/Network/readme_NW.html" class="nav-list-link">네트워크</a></li><li class="nav-list-item"><a href="/Network/network_basic.html" class="nav-list-link">네트워크의 기초</a></li><li class="nav-list-item"><a href="/Design%20Pattern/dp_revealing_module_pattern.html" class="nav-list-link">노출모듈 패턴 정의</a></li><li class="nav-list-item"><a href="/Algorithm/ag_dijkstra.html" class="nav-list-link">다익스트라(dijkstra) 알고리즘</a></li><li class="nav-list-item"><a href="/Database/db_migration.html" class="nav-list-link">데이터 마이그레이션 정리 노트</a></li><li class="nav-list-item"><a href="/Database/readme_DB.html" class="nav-list-link">데이터베이스</a></li><li class="nav-list-item"><a href="/Database/db_basic.html" class="nav-list-link">데이터베이스(Database) 기초</a></li><li class="nav-list-item"><a href="/Database/db_types_of_databases.html" class="nav-list-link">데이터베이스의 종류</a></li><li class="nav-list-item"><a href="/Design%20Pattern/readme_DP.html" class="nav-list-link">디자인패턴</a></li><li class="nav-list-item"><a href="/Network/network_load_balancing.html" class="nav-list-link">로드 밸런싱이란?</a></li><li class="nav-list-item"><a href="/Data%20Structure/ds_array_vector.html" class="nav-list-link">배열(Array)</a></li><li class="nav-list-item"><a href="/Database/db_backup_recovery.html" class="nav-list-link">백업(Backup)과 복구(Recovery)</a></li><li class="nav-list-item"><a href="/Database/db_distributed_database.html" class="nav-list-link">분산형 데이터베이스</a></li><li class="nav-list-item"><a href="/Algorithm/ag_divide_and_conquer.html" class="nav-list-link">분할 정복 알고리즘</a></li><li class="nav-list-item"><a href="/Algorithm/ag_bitMask.html" class="nav-list-link">비트마스크</a></li><li class="nav-list-item"><a href="/Algorithm/ag_permutation_combination.html" class="nav-list-link">순열 &amp; 조합</a></li><li class="nav-list-item"><a href="/Data%20Structure/ds_stack_queue.html" class="nav-list-link">스택 &amp; 큐</a></li><li class="nav-list-item"><a href="/Algorithm/ag_stack_queue.html" class="nav-list-link">스택 &amp; 큐</a></li><li class="nav-list-item"><a href="/Database/db_explain.html" class="nav-list-link">실행 계획(EXPLAIN) 분석</a></li><li class="nav-list-item"><a href="/Design%20Pattern/dp_singleton_pattern.html" class="nav-list-link">싱글톤 패턴</a></li><li class="nav-list-item"><a href="/Algorithm/readme_AG.html" class="nav-list-link">알고리즘</a></li><li class="nav-list-item"><a href="/Data%20Structure/ds_Time_Space%20Complexity.html" class="nav-list-link">알고리즘의 성능 분석: Big-O 표기법과 복잡도 이해하기</a></li><li class="nav-list-item"><a href="/Data%20Structure/ds_linked_list.html" class="nav-list-link">연결 리스트 (Linked List)</a></li><li class="nav-list-item"><a href="/OS/readme_OS.html" class="nav-list-link">운영체제</a></li><li class="nav-list-item"><a href="/Web/readme_Web.html" class="nav-list-link">웹</a></li><li class="nav-list-item"><a href="/Network/network_web_server.html" class="nav-list-link">웹 서버</a></li><li class="nav-list-item"><a href="/Database/db_event_sourcing_cqrs.html" class="nav-list-link">이벤트 소싱(Event Sourcing)과 CQRS(Command Query Responsibillity Segregation)</a></li><li class="nav-list-item"><a href="/Algorithm/ag_binary_search.html" class="nav-list-link">이분 탐색 (Binary Search)</a></li><li class="nav-list-item"><a href="/Data%20Structure/ds_binary_tree.html" class="nav-list-link">이진 트리, 이진 탐색 트리</a></li><li class="nav-list-item"><a href="/Data%20Structure/readme_DS.html" class="nav-list-link">자료구조</a></li><li class="nav-list-item"><a href="/Design%20Pattern/dp_strategy_pattern.html" class="nav-list-link">전략패턴(Strategy Pattern) 개요</a></li><li class="nav-list-item"><a href="/Database/db_normal_forms.html" class="nav-list-link">정규화</a></li><li class="nav-list-item"><a href="/Design%20Pattern/dp_observer_pattern.html" class="nav-list-link">정의</a></li><li class="nav-list-item"><a href="/Database/db_join.html" class="nav-list-link">조인(JOIN)</a></li><li class="nav-list-item"><a href="/Network/cookie_and_session.html" class="nav-list-link">쿠키 &amp; 세션</a></li><li class="nav-list-item"><a href="/Database/db_transaction.html" class="nav-list-link">트랜잭션(Transaction)</a></li><li class="nav-list-item"><a href="/Data%20Structure/ds_tree_graph.html" class="nav-list-link">트리와 그래프의 공통점</a></li><li class="nav-list-item"><a href="/Database/db_partitioning_sharding.html" class="nav-list-link">파티셔닝 (Partitioning)</a></li><li class="nav-list-item"><a href="/OS/os_process.html" class="nav-list-link">프로세스(Process)란?</a></li><li class="nav-list-item"><a href="/Design%20Pattern/dp_proxy_pattern.html" class="nav-list-link">프록시 패턴 (Proxy Pattern)</a></li><li class="nav-list-item"><a href="/Algorithm/ag_merge_sort.html" class="nav-list-link">합병 정렬(Merge Sort)</a></li><li class="nav-list-item"><a href="/Algorithm/ag_hashing.html" class="nav-list-link">해싱(Hashing)이란?</a></li><li class="nav-list-item"><a href="/Data%20Structure/ds_hash_table.html" class="nav-list-link">해싱, 해시 함수 란?</a></li><li class="nav-list-item"><a href="/Algorithm/ag_heap.html" class="nav-list-link">힙(Heap)</a></li><li class="nav-list-item"><a href="/Data%20Structure/ds_heap_priority_queue.html" class="nav-list-link">힙(Heap)</a></li><li class="nav-list-item"><a href="/Algorithm/ag_heap_sort.html" class="nav-list-link">힙(Heap)이란, 어떤 자료구조일까?</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Dev Open Library" aria-label="Search Dev Open Library" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div class="main-content-wrap"> <div id="main-content" class="main-content"> <main> <h1 id="query-optimizationslow-query-tuning"> <a href="#query-optimizationslow-query-tuning" class="anchor-heading" aria-labelledby="query-optimizationslow-query-tuning"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Query Optimization(Slow Query Tuning) </h1> <p>데이터베이스의 성능을 높이기 위해 SQL 쿼리를 분석하고 최적화하는 과정</p> <h2 id="슬로우-쿼리-원인"> <a href="#슬로우-쿼리-원인" class="anchor-heading" aria-labelledby="슬로우-쿼리-원인"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>슬로우 쿼리 원인</strong> </h2> <ol> <li><strong>인덱스 미사용 또는 잘못된 인덱스</strong> <ul> <li>적절한 인덱스가 없거나 과도한 인덱스를 사용하면 쿼리 성능이 저하</li> </ul> </li> <li><strong>불필요한 풀 테이블 스캔</strong> <ul> <li>적은 양의 데이터를 사용할 경우, 풀 테이블 스캔을 할 경우 성능 저하</li> </ul> </li> <li><strong>잘못된 조인 (JOIN) 순서 및 방식</strong> <ul> <li>조인의 순서나 방식에 따라 성능 차이가 큼</li> </ul> </li> <li><strong>과한 서브쿼리 사용</strong> <ul> <li>서브쿼리는 JOIN, EXISTS, IN으로 변경하는 것이 더 효율적일 수 있음</li> </ul> </li> <li><strong>트랜잭션 및 락 대기</strong> <ul> <li>긴 트랜잭션이 다른 쿼리들의 대기 상태를 유발할 수 있으므로 트랜잭션을 최소화하고 적절한 커밋 시점을 설정해야 함</li> </ul> </li> </ol> <h2 id="옵티마이저-힌트"> <a href="#옵티마이저-힌트" class="anchor-heading" aria-labelledby="옵티마이저-힌트"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 옵티마이저 힌트 </h2> <p>옵티마이저 힌트는 <strong>DBMS가 실행 계획을 최적화할 때 개발자가 특정 방식으로 실행하도록 유도하는 방법</strong></p> <p>DBMS는 보통 <strong>통계 정보(Statistics)</strong> 를 기반으로 자동으로 최적의 실행 계획을 선택하지만,</p> <ul> <li><strong>잘못된 통계 정보</strong></li> <li> <p><strong>특정 실행 계획을 강제하고 싶을 때</strong></p> <p>이런 경우에는 옵티마이저 힌트를 사용해서 직접 실행 계획을 컨트롤할 수 있다.</p> </li> </ul> <h3 id="대표적인-힌트-종류-dbms마다-다름"> <a href="#대표적인-힌트-종류-dbms마다-다름" class="anchor-heading" aria-labelledby="대표적인-힌트-종류-dbms마다-다름"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 대표적인 힌트 종류 (DBMS마다 다름) </h3> <div class="table-wrapper"><table> <thead> <tr> <th><strong>힌트 종류</strong></th> <th><strong>설명</strong></th> <th><strong>사용 예시</strong></th> </tr> </thead> <tbody> <tr> <td><strong>조인 방식 강제</strong></td> <td>특정 조인 방식을 강제함</td> <td><code class="language-plaintext highlighter-rouge">/*+ USE_NL(A B) */</code></td> </tr> <tr> <td><strong>조인 순서 강제</strong></td> <td>테이블의 조인 순서를 지정함</td> <td><code class="language-plaintext highlighter-rouge">/*+ LEADING(A B C) */</code></td> </tr> <tr> <td><strong>인덱스 사용 강제</strong></td> <td>특정 인덱스를 사용하도록 강제</td> <td><code class="language-plaintext highlighter-rouge">/*+ INDEX(table index_name) */</code></td> </tr> <tr> <td><strong>인덱스 사용 방지</strong></td> <td>특정 인덱스를 사용하지 않도록 강제</td> <td><code class="language-plaintext highlighter-rouge">/*+ NO_INDEX(table index_name) */</code></td> </tr> <tr> <td><strong>병렬 처리 적용</strong></td> <td>SQL 실행을 병렬로 수행</td> <td><code class="language-plaintext highlighter-rouge">/*+ PARALLEL(table 4) */</code></td> </tr> <tr> <td><strong>FULL 스캔 강제</strong></td> <td>테이블 풀 스캔을 강제</td> <td><code class="language-plaintext highlighter-rouge">/*+ FULL(table) */</code></td> </tr> <tr> <td><strong>INDEX 스캔 강제</strong></td> <td>특정 인덱스를 통한 검색 강제</td> <td><code class="language-plaintext highlighter-rouge">/*+ INDEX(table index_name) */</code></td> </tr> <tr> <td><strong>SORT MERGE 조인 강제</strong></td> <td>Sort Merge Join 사용</td> <td><code class="language-plaintext highlighter-rouge">/*+ USE_MERGE(A B) */</code></td> </tr> <tr> <td><strong>CARDINALITY 설정</strong></td> <td>특정 테이블의 예상 행 수를 지정</td> <td><code class="language-plaintext highlighter-rouge">/*+ CARDINALITY(table 1000) */</code></td> </tr> <tr> <td><strong>FIRST_ROWS / ALL_ROWS</strong></td> <td>응답 속도 또는 전체 처리 속도 최적화</td> <td><code class="language-plaintext highlighter-rouge">/*+ FIRST_ROWS(10) */</code></td> </tr> </tbody> </table></div> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*+ USE_NL(A B) */</span>    <span class="c1">-- A, B 테이블을 Nested Loop Join 사용</span>
<span class="cm">/*+ USE_HASH(A B) */</span>  <span class="c1">-- A, B 테이블을 Hash Join 사용, B가 해시 테이블로 올라감</span>

<span class="c1">-- NL 조인 강제</span>
<span class="k">SELECT</span> <span class="cm">/*+ USE_NL(usr ord) */</span> 
	<span class="n">usr</span><span class="p">.</span><span class="err">이름</span><span class="p">,</span> <span class="n">ord</span><span class="p">.</span><span class="err">상품이름</span><span class="p">,</span> <span class="n">ord</span><span class="p">.</span><span class="err">주문일자</span>
<span class="k">FROM</span> <span class="n">T_USER</span> <span class="n">usr</span>
<span class="k">JOIN</span> <span class="n">T_ORDER</span> <span class="n">ord</span>  <span class="k">ON</span> <span class="n">usr</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">ord</span><span class="p">.</span><span class="n">user_id</span>

<span class="c1">-- 해시 조인 강제</span>
<span class="k">SELECT</span> <span class="cm">/*+ USE_HASH(usr ord) */</span> 
	<span class="n">usr</span><span class="p">.</span><span class="err">이름</span><span class="p">,</span> <span class="n">ord</span><span class="p">.</span><span class="err">상품이름</span><span class="p">,</span> <span class="n">ord</span><span class="p">.</span><span class="err">주문일자</span>
<span class="k">FROM</span> <span class="n">T_USER</span> <span class="n">usr</span>
<span class="k">JOIN</span> <span class="n">T_ORDER</span> <span class="n">ord</span>  <span class="k">ON</span> <span class="n">usr</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">ord</span><span class="p">.</span><span class="n">user_id</span>

<span class="cm">/*+ LEADING(A B C) */</span> <span class="c1">-- A → B → C 순서대로 조인 강제</span>

<span class="c1">-- ord 테이블을 먼저 읽도록 강제</span>
<span class="k">SELECT</span> <span class="cm">/*+ LEADING(ord usr) */</span> 
	<span class="n">usr</span><span class="p">.</span><span class="err">이름</span><span class="p">,</span> <span class="n">ord</span><span class="p">.</span><span class="err">상품이름</span><span class="p">,</span> <span class="n">ord</span><span class="p">.</span><span class="err">주문일자</span>
<span class="k">FROM</span> <span class="n">T_USER</span> <span class="n">usr</span>
<span class="k">JOIN</span> <span class="n">T_ORDER</span> <span class="n">ord</span>  <span class="k">ON</span> <span class="n">usr</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">ord</span><span class="p">.</span><span class="n">user_id</span>

<span class="cm">/*+ INDEX(table index_name) */</span>       <span class="c1">-- 테이블의 index_name 사용</span>
<span class="cm">/*+ NO_INDEX(table index_name) */</span>    <span class="c1">-- 테이블의 index_name 사용x</span>

<span class="c1">-- 해시 조인, idx_user_id 인덱스 사용</span>
<span class="k">SELECT</span> <span class="cm">/*+ USE_HASH(usr ord) INDEX(usr idx_user_id) */</span> 
	<span class="n">usr</span><span class="p">.</span><span class="err">이름</span><span class="p">,</span> <span class="n">ord</span><span class="p">.</span><span class="err">상품이름</span><span class="p">,</span> <span class="n">ord</span><span class="p">.</span><span class="err">주문일자</span>
<span class="k">FROM</span> <span class="n">T_USER</span> <span class="n">usr</span>
<span class="k">JOIN</span> <span class="n">T_ORDER</span> <span class="n">ord</span>  <span class="k">ON</span> <span class="n">usr</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">ord</span><span class="p">.</span><span class="n">user_id</span>

<span class="cm">/*+ PARALLEL(table 4) */</span>       <span class="c1">-- 테이블을 4개의 프로세스가 병렬로 처리하도록 강제</span>

<span class="k">SELECT</span> <span class="cm">/*+ PARALLEL(T_ORDER 4) */</span> 
       <span class="n">user_id</span><span class="p">,</span> <span class="err">상품이름</span><span class="p">,</span> <span class="err">주문일자</span>
<span class="k">FROM</span> <span class="n">T_ORDER</span><span class="p">;</span>

<span class="c1">-- T_USER와 T_ORDER 테이블을 각각 4개의 프로세스로 병렬 처리</span>
<span class="k">SELECT</span> <span class="cm">/*+ PARALLEL(T_ORDER 4) PARALLEL(T_USER 4) */</span> 
	<span class="n">usr</span><span class="p">.</span><span class="err">이름</span><span class="p">,</span> <span class="n">ord</span><span class="p">.</span><span class="err">상품이름</span><span class="p">,</span> <span class="n">ord</span><span class="p">.</span><span class="err">주문일자</span>
<span class="k">FROM</span> <span class="n">T_USER</span> <span class="n">usr</span>
<span class="k">JOIN</span> <span class="n">T_ORDER</span> <span class="n">ord</span>  <span class="k">ON</span> <span class="n">usr</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">ord</span><span class="p">.</span><span class="n">user_id</span>
</code></pre></div></div> <h3 id="주의점"> <a href="#주의점" class="anchor-heading" aria-labelledby="주의점"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 주의점 </h3> <ol> <li>힌트는 DBMS에 따라 다르다.</li> <li>힌트를 무조건 쓰면 안된다. <ul> <li>옵티마이저가 최적 실행 계획을 찾는 경우가 많음</li> <li>장기적으로 유지보수가 어려워질 수 있음</li> </ul> </li> </ol> <h1 id="쿼리-최적화"> <a href="#쿼리-최적화" class="anchor-heading" aria-labelledby="쿼리-최적화"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>쿼리 최적화</strong> </h1> <p><img src="/Database/img/db_query_optimization_1.png" alt="" /></p> <h2 id="1-실행-계획explain-execution-plan-확인"> <a href="#1-실행-계획explain-execution-plan-확인" class="anchor-heading" aria-labelledby="1-실행-계획explain-execution-plan-확인"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>1. 실행 계획(EXPLAIN, EXECUTION PLAN) 확인</strong> </h2> <p><strong>실행 계획을 분석하여 쿼리 성능을 점검</strong>할 수 있다.</p> <ul> <li><strong>MySQL:</strong> <code class="language-plaintext highlighter-rouge">EXPLAIN SELECT ...</code></li> <li><strong>Oracle/Tibero:</strong> <code class="language-plaintext highlighter-rouge">EXPLAIN PLAN FOR SELECT ...</code></li> <li><strong>PostgreSQL:</strong> <code class="language-plaintext highlighter-rouge">EXPLAIN ANALYZE SELECT ...</code></li> </ul> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">EXPLAIN</span> <span class="n">PLAN</span> <span class="k">FOR</span>
<span class="k">SELECT</span> <span class="cm">/*+ full(user_id)*/</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">T_USER</span>
<span class="k">WHERE</span> <span class="n">user_id</span><span class="o">=</span> <span class="s1">'USER000502'</span>

<span class="k">SELECT</span> 
	<span class="n">SQL_ID</span>
	<span class="p">,</span> <span class="k">OPERATION</span>
	<span class="p">,</span> <span class="n">OBJECT_NAME</span>
	<span class="p">,</span> <span class="n">SEARCH_COLUMNS</span>
	<span class="p">,</span> <span class="n">COST</span>
<span class="k">FROM</span> <span class="n">PLAN_TABLE</span>
<span class="k">WHERE</span> <span class="n">SQL_ID</span> <span class="k">IN</span> <span class="p">(</span> <span class="s1">'51s88agb5q2fw'</span><span class="p">,</span> <span class="s1">'5xfxqjnpxhuvw'</span> <span class="p">)</span>
</code></pre></div></div> <p><img src="/Database/img/db_query_optimization_2.png" alt="" /></p> <h2 id="2-인덱스-최적화"> <a href="#2-인덱스-최적화" class="anchor-heading" aria-labelledby="2-인덱스-최적화"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>2. 인덱스 최적화</strong> </h2> <p>✅</p> <ul> <li>WHERE, JOIN, ORDER BY, GROUP BY에서 인덱스를 제대로 활용하고 있는가?</li> <li>불필요한 인덱스가 오히려 성능 저하를 유발하지 않는가?</li> <li>인덱스가 많은 경우 유지 관리 비용을 고려했는가?</li> <li>예상치 못한 TABLE FULL SCAN이 발생하지 않는가?</li> <li>적절한 인덱스 사용으로 풀스캔을 줄였는가?</li> </ul> <h3 id="인덱스-최적화-목표"> <a href="#인덱스-최적화-목표" class="anchor-heading" aria-labelledby="인덱스-최적화-목표"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>인덱스 최적화 목표</strong> </h3> <ul> <li>스캔 과정에서 발생하는 비효율 줄이기</li> <li>테이블 액세스 회수 줄이기</li> </ul> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">T_USER</span>
<span class="k">WHERE</span> <span class="n">user_id</span><span class="o">=</span> <span class="s1">'USER000502'</span>
<span class="o">//</span> <span class="err">조건에</span> <span class="err">해당하는</span> <span class="err">데이터가</span> <span class="err">한</span> <span class="err">건이므로</span> <span class="err">인덱스를</span> <span class="err">사용하는</span> <span class="err">방식이</span> <span class="err">좋다</span><span class="p">.</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">T_USER</span>
<span class="k">WHERE</span> <span class="err">유저구분코드</span> <span class="o">=</span> <span class="s1">'a001'</span>
<span class="o">//</span> <span class="err">유저구분코드가</span> <span class="s1">'a001'</span><span class="err">인</span> <span class="err">고객</span> <span class="err">데이터가</span> <span class="mi">100</span><span class="err">만</span> <span class="err">건일</span> <span class="err">때</span><span class="p">,</span> <span class="err">풀</span> <span class="err">스캔</span> <span class="err">방식이</span> <span class="err">효과적이다</span><span class="p">.</span>
</code></pre></div></div> <p>인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다. (목차) <img src="/Database/img/db_query_optimization_3.png" alt="" /></p> <p>index range scan 을 할 때는 데이터가 정렬되어 있어야 하고 스캔 시작점과 종료점(인덱스 블록에서 스캔하는 양)이 중요</p> <p>✅ <strong>적절한 인덱스 추가</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_user_name</span> <span class="k">ON</span> <span class="n">T_USER</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</code></pre></div></div> <ul> <li>자주 조회되는 컬럼이나 <strong>조인 조건에 사용되는 컬럼</strong>에 인덱스를 추가</li> </ul> <p>✅ <strong>복합 인덱스</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_orders_user_date</span> <span class="k">ON</span> <span class="n">T_ORDER</span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">order_date</span><span class="p">);</span>
</code></pre></div></div> <ul> <li>WHERE 절에 다중 컬럼을 사용할 경우 사용</li> <li>인덱스 순서도 중요 <ul> <li><code class="language-plaintext highlighter-rouge">WHERE user_id = 1 AND order_date = '2024-03-01'</code> <ul> <li>인덱스 사용 가능</li> <li>user_id로 스캔 범위를 좁힐 수 있음</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">WHERE order_date = '2024-03-01'</code> <ul> <li>모든 데이터를 조회해야 할 수 있음</li> </ul> </li> </ul> </li> </ul> <h2 id="3-join-최적화"> <a href="#3-join-최적화" class="anchor-heading" aria-labelledby="3-join-최적화"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>3. JOIN 최적화</strong> </h2> <p>✅</p> <ul> <li>INNER JOIN이 OUTER JOIN보다 적절한가?</li> <li>조인 순서를 변경하면 성능이 향상되는가?</li> <li>조인 대상 테이블에 적절한 인덱스가 설정되어 있는가?</li> </ul> <h3 id="nlnested-loops-조인"> <a href="#nlnested-loops-조인" class="anchor-heading" aria-labelledby="nlnested-loops-조인"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>NL(Nested Loops) 조인</strong> </h3> <ul> <li>인덱스를 이용한 조인</li> <li>작은 테이블을 먼저 읽고, 그 값으로 큰 테이블을 조회</li> <li>인덱스가 잘 활용되지 않으면 성능이 저하될 수 있음</li> </ul> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">a</span><span class="p">.</span><span class="err">이름</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="err">상품이름</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="err">주문일자</span>
<span class="k">FROM</span> <span class="n">T_USER</span> <span class="n">a</span><span class="p">,</span> <span class="n">T_ORDER</span> <span class="n">b</span>
<span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">AND</span> <span class="n">a</span><span class="p">.</span><span class="err">가입일자</span> <span class="o">=</span> <span class="s1">'20250101'</span>
</code></pre></div></div> <h3 id="nl-조인-동작-방식"> <a href="#nl-조인-동작-방식" class="anchor-heading" aria-labelledby="nl-조인-동작-방식"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>NL 조인 동작 방식</strong> </h3> <ol> <li>T_USER 테이블에서 데이터를 가져옴 <ul> <li><code class="language-plaintext highlighter-rouge">가입일자 = '20250101'</code> 조건을 만족하는 유저 조회</li> </ul> </li> <li>각 유저의 <code class="language-plaintext highlighter-rouge">user_id</code>로 T_ORDER 테이블을 검색 <ul> <li>T_USER 에서 가져온 <code class="language-plaintext highlighter-rouge">user_id</code>를 이용해 <code class="language-plaintext highlighter-rouge">T_ORDER</code> 테이블에서 해당 유저의 주문 데이터를 조회</li> </ul> </li> <li>반복 <ul> <li> <p>위 과정을 모든 유저에 대해 반복 수행</p> <p><img src="/Database/img/db_query_optimization_4.png" alt="" /></p> </li> </ul> </li> </ol> <h3 id="실행-계획"> <a href="#실행-계획" class="anchor-heading" aria-labelledby="실행-계획"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>실행 계획</strong> </h3> <p>| 단계 | 연산(Operation) | 테이블 | 액세스 방식(Access Method) | | — | — | — | — | | 1 | TABLE ACCESS BY INDEX ROWID | T_USER | <code class="language-plaintext highlighter-rouge">가입일자</code> 필터링 (INDEX 사용) | | 2 | INDEX RANGE SCAN | idx_user_join_date | <code class="language-plaintext highlighter-rouge">가입일자</code> 인덱스 탐색 | | 3 | NESTED LOOPS | | | | 4 | TABLE ACCESS BY INDEX ROWID | T_ORDER | <code class="language-plaintext highlighter-rouge">user_id</code> 인덱스를 통한 검색 | | 5 | INDEX UNIQUE SCAN | idx_order_user_id | <code class="language-plaintext highlighter-rouge">user_id</code> 인덱스를 사용한 검색 |</p> <ul> <li>T_USER에서 먼저 가입일자 조건을 필터링 (<code class="language-plaintext highlighter-rouge">INDEX RANGE SCAN</code>)</li> <li>그 결과를 기반으로 T_ORDER를 NESTED LOOPS 방식으로 반복 조회</li> </ul> <p>✅ <strong>조인 조건에 인덱스 추가</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_order_user_id</span> <span class="k">ON</span> <span class="n">T_ORDER</span><span class="p">(</span><span class="n">user_id</span><span class="p">);</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">T_ORDER.user_id</code>에 인덱스를 추가하면 <code class="language-plaintext highlighter-rouge">INDEX UNIQUE SCAN</code>이 발생하며 빠르게 조인 가능</li> </ul> <p>✅ <strong>드라이빙 테이블 크기 줄이기</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_user_join_date</span> <span class="k">ON</span> <span class="n">T_USER</span><span class="p">(</span><span class="err">가입일자</span><span class="p">);</span>
</code></pre></div></div> <ul> <li>필터링 조건이 먼저 최적화되어야 <code class="language-plaintext highlighter-rouge">T_USER</code>의 크기가 줄어들어 NL 조인의 반복 횟수가 감소함</li> </ul> <h2 id="hash-join"> <a href="#hash-join" class="anchor-heading" aria-labelledby="hash-join"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>Hash Join</strong> </h2> <p>두 개의 테이블 중 <strong>작은 테이블을 메모리에 해시 테이블로 저장</strong>한 후, 큰 테이블을 스캔하면서 해시 테이블과 조인하는 방식</p> <ol> <li>NL 조인이 비효율적일 때 (인덱스를 활용하지 못할 때) <ul> <li>NL 조인은 데이터가 적을 때는 효율적이지만, <strong>대량 데이터 조인 시 비효율적</strong>일 수 있음</li> </ul> </li> <li>드라이빙 테이블이 작을 때</li> </ol> <h3 id="hash-join동작-방식"> <a href="#hash-join동작-방식" class="anchor-heading" aria-labelledby="hash-join동작-방식"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>Hash Join동작 방식</strong> </h3> <ol> <li><strong>Build</strong> <ul> <li>작은 테이블을 메모리에 올려 <strong>해시 테이블을 생성</strong></li> <li>조인 키를 기준으로 해시 값을 계산하여 <strong>버킷</strong>에 저장.</li> </ul> </li> <li><strong>Probe</strong> <ul> <li>큰 테이블을 읽으면서 해시 테이블을 참조하여 매칭되는 행을 탐색</li> </ul> </li> </ol> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="cm">/*+ USE_HASH(b) */</span> <span class="n">a</span><span class="p">.</span><span class="err">이름</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="err">상품이름</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="err">주문일자</span>
<span class="k">FROM</span> <span class="n">T_USER</span> <span class="n">a</span><span class="p">,</span> <span class="n">T_ORDER</span> <span class="n">b</span>
<span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">AND</span> <span class="n">a</span><span class="p">.</span><span class="err">가입일자</span> <span class="o">=</span> <span class="s1">'20250101'</span><span class="p">;</span>
</code></pre></div></div> <ol> <li> <p><strong><code class="language-plaintext highlighter-rouge">T_USER</code>(작은 테이블)에서 <code class="language-plaintext highlighter-rouge">가입일자 = '20250101'</code> 필터링</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">SELECT</span> <span class="n">user_id</span><span class="p">,</span> <span class="err">이름</span>
 <span class="k">FROM</span> <span class="n">T_USER</span>
 <span class="k">WHERE</span> <span class="err">가입일자</span> <span class="o">=</span> <span class="s1">'20250101'</span><span class="p">;</span>
</code></pre></div> </div> <ul> <li>이 결과를 해시 테이블로 메모리에 저장</li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">T_ORDER</code>(큰 테이블)를 스캔하며 <code class="language-plaintext highlighter-rouge">user_id</code>를 해시 테이블과 비교</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">SELECT</span> <span class="err">상품이름</span><span class="p">,</span> <span class="err">주문일자</span>
 <span class="k">FROM</span> <span class="n">T_ORDER</span>
 <span class="k">WHERE</span> <span class="n">user_id</span> <span class="k">IN</span> <span class="p">(</span><span class="err">해시</span> <span class="err">테이블</span><span class="p">);</span>
</code></pre></div> </div> <ul> <li><code class="language-plaintext highlighter-rouge">T_ORDER.user_id</code>를 해시 테이블에서 찾으며 빠르게 조인</li> </ul> </li> </ol> <p>✅ <strong>드라이빙 테이블(작은 테이블) 크기를 줄이기</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="cm">/*+ USE_HASH(b) */</span> <span class="n">a</span><span class="p">.</span><span class="err">이름</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="err">상품이름</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="err">주문일자</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">user_id</span><span class="p">,</span> <span class="err">이름</span> <span class="k">FROM</span> <span class="n">T_USER</span> <span class="k">WHERE</span> <span class="err">가입일자</span> <span class="o">=</span> <span class="s1">'20250101'</span><span class="p">)</span> <span class="n">a</span>
<span class="k">JOIN</span> <span class="n">T_ORDER</span> <span class="n">b</span>
<span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">user_id</span><span class="p">;</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">T_USER</code>에서 미리 필터링하여 <strong>해시 테이블 크기를 줄임</strong> → 더 빠른 해시 매칭 가능.</li> </ul> <p>✅ <strong>해시 테이블이 너무 클 경우, Hash Partitioning 사용</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">T_ORDER</span> <span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">HASH</span> <span class="p">(</span><span class="n">user_id</span><span class="p">);</span>
</code></pre></div></div> <ul> <li>해시 파티셔닝을 통해 데이터 분산 → 메모리 사용 최적화.</li> </ul> <h2 id="join-qa"> <a href="#join-qa" class="anchor-heading" aria-labelledby="join-qa"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Join Q&amp;A </h2> <h3 id="1-nosql에서는-쿼리-최적화가-있는지"> <a href="#1-nosql에서는-쿼리-최적화가-있는지" class="anchor-heading" aria-labelledby="1-nosql에서는-쿼리-최적화가-있는지"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1. NoSQL에서는 쿼리 최적화가 있는지? </h3> <p>✅ NoSQL에서도 쿼리 최적화는 필요</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NoSQL은 스키마가 유연하고 조인이 적다는 특성이 있지만, 
데이터가 많아지면 느려지는 쿼리를 최적화해야 하는 건 같다.

- RDBMS → 실행 계획 &amp; 인덱스 튜닝을 통해 최적화
- NoSQL → 적절한 데이터 모델링 + 인덱싱 + 샤딩(Sharding) + 캐싱
</code></pre></div></div> <h3 id="2-nl-조인-hash-join도-inner-join-같은-건가"> <a href="#2-nl-조인-hash-join도-inner-join-같은-건가" class="anchor-heading" aria-labelledby="2-nl-조인-hash-join도-inner-join-같은-건가"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2. NL 조인, Hash Join도 inner join 같은 건가? </h3> <p>✅ NL 조인, Hash Join 은 join의 실행방식 중 하나</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NL 조인과 해시 조인은 조인의 실행 방식이 다른 알고리즘으로 
같은 조인을 수행하지만, 데이터를 매칭하는 방식이 다른 것
</code></pre></div></div> <h3 id="3-만약-큰-테이블과-작은-테이블이-같은-경우는-어떤-조인을-사용하는게-좋을지"> <a href="#3-만약-큰-테이블과-작은-테이블이-같은-경우는-어떤-조인을-사용하는게-좋을지" class="anchor-heading" aria-labelledby="3-만약-큰-테이블과-작은-테이블이-같은-경우는-어떤-조인을-사용하는게-좋을지"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3. 만약 큰 테이블과 작은 테이블이 같은 경우는 어떤 조인을 사용하는게 좋을지? </h3> <p>✅ 상황(인덱스, 메모리..) 에 따라 다름</p> <p><strong>NL 조인 vs 해시 조인</strong></p> <div class="table-wrapper"><table> <thead> <tr> <th>기준</th> <th>NL 조인</th> <th>해시 조인</th> </tr> </thead> <tbody> <tr> <td><strong>인덱스</strong></td> <td>인덱스가 있을 때 유리 (빠름)</td> <td>인덱스 없어도 빠름</td> </tr> <tr> <td><strong>데이터 양</strong></td> <td>작은 테이블 + 큰 테이블</td> <td>두 테이블 크기가 비슷할 때</td> </tr> <tr> <td><strong>조인 방식</strong></td> <td>한쪽 테이블을 읽으며 다른 테이블 검색 (반복문)</td> <td>한쪽을 해시 테이블로 변환 후 조인</td> </tr> <tr> <td><strong>메모리 사용</strong></td> <td>적음 (인덱스 기반)</td> <td>많음 (해시 테이블 생성)</td> </tr> <tr> <td><strong>성능</strong></td> <td>인덱스 최적화 시 매우 빠름</td> <td>대량 데이터에서 빠름</td> </tr> </tbody> </table></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>인덱스가 있고 최적화 되어 있다 → NL
인덱스가 없다 → 해시 조인
메모리가 충분하다 → 해시 조인

결국 실행 환경에 따라 다르기 때문에 EXPLAIN PLAN을 확인해서 
실제 DB에서 어떤 방식이 최적화되는지 봐야 함.
</code></pre></div></div> <h2 id="4-서브쿼리-최적화"> <a href="#4-서브쿼리-최적화" class="anchor-heading" aria-labelledby="4-서브쿼리-최적화"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>4. 서브쿼리 최적화</strong> </h2> <p>✅</p> <ul> <li>서브쿼리를 JOIN 또는 EXISTS로 변경하면 성능이 향상되는가?</li> <li>IN 대신 EXISTS를 사용하면 더 효율적인가?</li> </ul> <h3 id="서브쿼리-문제점"> <a href="#서브쿼리-문제점" class="anchor-heading" aria-labelledby="서브쿼리-문제점"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 서브쿼리 문제점 </h3> <div class="table-wrapper"><table> <thead> <tr> <th>문제점</th> <th> </th> <th>예시</th> </tr> </thead> <tbody> <tr> <td><strong>반복 실행</strong></td> <td><strong>상관 서브쿼리</strong>는 메인 쿼리의 각 행마다 서브쿼리를 반복 실행함</td> <td><code class="language-plaintext highlighter-rouge">WHERE EXISTS (SELECT ... WHERE o.user_id = u.user_id)</code></td> </tr> <tr> <td><strong>옵티마이저가 최적화하기 어려움</strong></td> <td>옵티마이저는 블록 단위로 계획을 세우는데, <strong>서브쿼리 내부는 다른 블록</strong>이라 예측 어려움</td> <td>옵티마이저가 조인 방식 선택 실패 가능</td> </tr> <tr> <td><strong>인덱스 활용이 어려움</strong></td> <td>복잡하거나 상관된 서브쿼리는 <strong>풀스캔 유도</strong> 가능성 높음</td> <td><code class="language-plaintext highlighter-rouge">IN (SELECT ...)</code> 구조에서 옵티마이저가 인덱스를 포기할 수 있음</td> </tr> </tbody> </table></div> <p>💡 서브쿼리는 “옵티마이저가 잘 예측하지 못하는” 특성이 있어 주의가 필요</p> <h3 id="옵티마이저는-쿼리-블록-단위로-최적화를-수행한다"> <a href="#옵티마이저는-쿼리-블록-단위로-최적화를-수행한다" class="anchor-heading" aria-labelledby="옵티마이저는-쿼리-블록-단위로-최적화를-수행한다"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 옵티마이저는 쿼리 블록 단위로 최적화를 수행한다. </h3> <ul> <li>쿼리 블록 단위로 최적화됨 → <code class="language-plaintext highlighter-rouge">EXISTS</code>, <code class="language-plaintext highlighter-rouge">IN</code>, <code class="language-plaintext highlighter-rouge">JOIN</code>은 다른 블록처럼 처리됨</li> <li>서브쿼리의 실행 시점은 메인 쿼리 이후인 경우가 많음</li> <li> <p>특히 상관 서브쿼리는 메인 쿼리 한 줄당 서브쿼리 한 번 실행되므로 매우 비효율적</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">SELECT</span> <span class="err">이름</span>
  <span class="k">FROM</span> <span class="n">T_USER</span> <span class="n">u</span>
  <span class="k">WHERE</span> <span class="err">가입일자</span> <span class="o">=</span> <span class="s1">'20250101'</span>
  <span class="k">AND</span> <span class="k">EXISTS</span> <span class="p">(</span>
      <span class="k">SELECT</span> <span class="mi">1</span>
      <span class="k">FROM</span> <span class="n">T_ORDER</span> <span class="n">o</span>
      <span class="k">WHERE</span> <span class="n">o</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">user_id</span>
      <span class="k">AND</span> <span class="n">o</span><span class="p">.</span><span class="err">상품이름</span> <span class="o">=</span> <span class="s1">'라면'</span>
  <span class="p">);</span>
    
  <span class="o">&lt;</span><span class="err">블록</span> <span class="mi">1</span><span class="o">&gt;</span>
  <span class="k">SELECT</span> <span class="err">이름</span>
  <span class="k">FROM</span> <span class="n">T_USER</span> <span class="n">u</span>
  <span class="k">WHERE</span> <span class="err">가입일자</span> <span class="o">=</span> <span class="s1">'20250101'</span>
    
  <span class="o">&lt;</span><span class="err">블록</span> <span class="mi">2</span><span class="o">&gt;</span>
  <span class="k">SELECT</span> <span class="mi">1</span>
  <span class="k">FROM</span> <span class="n">T_ORDER</span>
  <span class="k">WHERE</span> <span class="n">user_id</span> <span class="o">=</span> <span class="p">:</span><span class="n">user_id</span> <span class="c1">-- 블록 1의 user_id 값을 하나씩 바인딩 받아 실행</span>
  <span class="k">AND</span> <span class="err">상품이름</span> <span class="o">=</span> <span class="s1">'라면'</span>
</code></pre></div> </div> </li> </ul> <h3 id="예시"> <a href="#예시" class="anchor-heading" aria-labelledby="예시"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 예시 </h3> <h3 id="서브쿼리-느릴-수-있음"> <a href="#서브쿼리-느릴-수-있음" class="anchor-heading" aria-labelledby="서브쿼리-느릴-수-있음"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 서브쿼리 (느릴 수 있음) </h3> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="err">이름</span>
<span class="k">FROM</span> <span class="n">T_USER</span>
<span class="k">WHERE</span> <span class="n">user_id</span> <span class="k">IN</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">user_id</span>
    <span class="k">FROM</span> <span class="n">T_ORDER</span>
    <span class="k">WHERE</span> <span class="err">상품이름</span> <span class="o">=</span> <span class="s1">'라면'</span>
<span class="p">)</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">T_ORDER</code> 먼저 수행</li> <li><code class="language-plaintext highlighter-rouge">T_USER</code>를 조건 비교로 필터링</li> <li>옵티마이저가 <strong>인덱스 사용 안 할 수 있음</strong></li> <li><strong>대용량 비추</strong>, 소규모라면 괜찮음</li> </ul> <h3 id="join-일반적으로-더-효율적"> <a href="#join-일반적으로-더-효율적" class="anchor-heading" aria-labelledby="join-일반적으로-더-효율적"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> JOIN (일반적으로 더 효율적) </h3> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">u</span><span class="p">.</span><span class="err">이름</span>
<span class="k">FROM</span> <span class="n">T_USER</span> <span class="n">u</span>
<span class="k">JOIN</span> <span class="n">T_ORDER</span> <span class="n">o</span> <span class="k">ON</span> <span class="n">u</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">WHERE</span> <span class="n">o</span><span class="p">.</span><span class="err">상품이름</span> <span class="o">=</span> <span class="s1">'라면'</span>
</code></pre></div></div> <ul> <li>옵티마이저가 <strong>해시 조인 / NL 조인 / 병렬 처리 등 다양한 선택 가능</strong></li> <li>인덱스 사용 가능</li> <li><strong>전체적으로 가장 안정적이고 빠름</strong></li> </ul> <h3 id="exists-조건만-확인"> <a href="#exists-조건만-확인" class="anchor-heading" aria-labelledby="exists-조건만-확인"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> EXISTS (조건만 확인) </h3> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="err">이름</span>
<span class="k">FROM</span> <span class="n">T_USER</span> <span class="n">u</span>
<span class="k">WHERE</span> <span class="k">EXISTS</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="mi">1</span>
    <span class="k">FROM</span> <span class="n">T_ORDER</span> <span class="n">o</span>
    <span class="k">WHERE</span> <span class="n">o</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">user_id</span>
    <span class="k">AND</span> <span class="n">o</span><span class="p">.</span><span class="err">상품이름</span> <span class="o">=</span> <span class="s1">'라면'</span>
<span class="p">);</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">T_USER</code> 한 건씩 조회하며 <code class="language-plaintext highlighter-rouge">T_ORDER</code>에 조건 만족하는 것 있으면 탈출</li> <li>조건이 <strong>존재 여부</strong>일 때 매우 효율적</li> <li><strong>중복 제거 불필요</strong>, 빠른 탈출 덕분에 쿼리 시간 단축 가능</li> </ul> <h3 id="비교"> <a href="#비교" class="anchor-heading" aria-labelledby="비교"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 비교 </h3> <div class="table-wrapper"><table> <thead> <tr> <th> </th> <th>JOIN</th> <th>EXISTS</th> <th>IN</th> </tr> </thead> <tbody> <tr> <td>가장 효율적인 기본 방식</td> <td>✅</td> <td>✅ (존재 확인)</td> <td>❌ (옵티마이저 예측 어려움)</td> </tr> <tr> <td>대용량 적합</td> <td>✅</td> <td>주의 필요</td> <td>❌</td> </tr> <tr> <td>인덱스 활용</td> <td>최적화됨</td> <td>가능</td> <td>어려움</td> </tr> <tr> <td>실행계획 최적화</td> <td>유리</td> <td>비교적 유리</td> <td>불리</td> </tr> <tr> <td>추천 상황</td> <td><strong>실제 데이터를 함께 보여줄 때</strong></td> <td>조건 충족하는 데이터가 <strong>존재하는지만 확인</strong>할 때</td> <td>서브쿼리 결과가 <strong>작고 고정된 범위</strong>일 때</td> </tr> </tbody> </table></div> <p><strong>서브쿼리</strong> → 간단한 조건이나 상관관계 없는 서브쿼리 일 때 추천</p> <h2 id="트랜잭션-및-락-대기"> <a href="#트랜잭션-및-락-대기" class="anchor-heading" aria-labelledby="트랜잭션-및-락-대기"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 트랜잭션 및 락 대기 </h2> <p>✅</p> <ul> <li>트랜잭션 유지 시간을 최소화하여 락 대기를 줄였는가?</li> <li>적절한 커밋 타이밍을 설정하여 롤백 부담을 줄였는가?</li> </ul> <div class="table-wrapper"><table> <thead> <tr> <th>트랜잭션</th> <th>하나의 논리적 작업 단위 (<code class="language-plaintext highlighter-rouge">BEGIN ~ COMMIT/ROLLBACK</code>)</th> <th>DB에 변경이 필요한 최소 범위로 한정</th> </tr> </thead> <tbody> <tr> <td>락(Lock)</td> <td>데이터 무결성을 위한 배타 제어 수단</td> <td>행 단위 락(Row-level Lock)을 유도하도록 SQL 설계</td> </tr> <tr> <td>락 대기(Lock Wait)</td> <td>선행 트랜잭션이 락을 해제하지 않아서 후속 쿼리가 멈추는 현상</td> <td>락이 오래 지속되면 블로킹 발생</td> </tr> <tr> <td>블로킹</td> <td>특정 트랜잭션이 다른 트랜잭션의 실행을 막는 상태</td> <td>보통 <code class="language-plaintext highlighter-rouge">COMMIT</code> 또는 <code class="language-plaintext highlighter-rouge">ROLLBACK</code>으로 해제됨</td> </tr> <tr> <td>교착 상태(Deadlock)</td> <td>두 트랜잭션이 서로의 락을 기다리며 영원히 대기</td> <td>DBMS가 한 트랜잭션을 강제 종료시켜 회피함</td> </tr> </tbody> </table></div> <h3 id="왜-트랜잭션이-길면-위험할까"> <a href="#왜-트랜잭션이-길면-위험할까" class="anchor-heading" aria-labelledby="왜-트랜잭션이-길면-위험할까"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 왜 트랜잭션이 길면 위험할까? </h3> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 사용자 A</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">T_ORDER</span> <span class="k">SET</span> <span class="err">상태</span> <span class="o">=</span> <span class="s1">'배송중'</span> <span class="k">WHERE</span> <span class="err">주문번호</span> <span class="o">=</span> <span class="mi">12345</span><span class="p">;</span>
<span class="c1">-- commit; (여기서 커밋 안 함)</span>

<span class="c1">-- 사용자 B (다른 세션)</span>
<span class="k">UPDATE</span> <span class="n">T_ORDER</span> <span class="k">SET</span> <span class="err">상태</span> <span class="o">=</span> <span class="s1">'완료'</span> <span class="k">WHERE</span> <span class="err">주문번호</span> <span class="o">=</span> <span class="mi">12345</span><span class="p">;</span>
<span class="c1">-- B는 A가 커밋하기 전까지 '락 상태'</span>

</code></pre></div></div> <ul> <li>락이 오래 유지되면 다른 사용자도 모두 기다림</li> <li>트랜잭션 안에서 많은 작업을 하면, <strong>롤백 시 복구 비용</strong>도 커짐</li> <li>트랜잭션이 복잡해질수록 교착 상태 발생 확률도 높아짐</li> </ul> <h3 id="비관적-락-vs-낙관적-락"> <a href="#비관적-락-vs-낙관적-락" class="anchor-heading" aria-labelledby="비관적-락-vs-낙관적-락"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 비관적 락 vs 낙관적 락 </h3> <div class="table-wrapper"><table> <thead> <tr> <th> </th> <th>비관적 락</th> <th>낙관적 락</th> </tr> </thead> <tbody> <tr> <td>개념</td> <td>미리 락을 걸어 충돌을 방지</td> <td>충돌이 날 경우 롤백</td> </tr> <tr> <td>방법</td> <td><code class="language-plaintext highlighter-rouge">SELECT ... FOR UPDATE</code></td> <td><code class="language-plaintext highlighter-rouge">version</code>, <code class="language-plaintext highlighter-rouge">updated_at</code> 등 비교</td> </tr> <tr> <td>장점</td> <td>충돌 확실히 방지</td> <td>락을 걸지 않아 성능 우수</td> </tr> <tr> <td>단점</td> <td>락 유지 시간 증가 → 성능 저하</td> <td>충돌 시 재시도 필요</td> </tr> <tr> <td>추천 상황</td> <td>동시 수정 가능성 높을 때</td> <td>대부분 읽기 전용, 충돌 드물 때</td> </tr> </tbody> </table></div> <h3 id="정리"> <a href="#정리" class="anchor-heading" aria-labelledby="정리"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 정리 </h3> <div class="table-wrapper"><table> <thead> <tr> <th>트랜잭션 최소화</th> <th>트랜잭션 범위를 최대한 좁힘</th> </tr> </thead> <tbody> <tr> <td>빠른 커밋</td> <td>처리 로직 후 즉시 커밋</td> </tr> <tr> <td>SELECT는 트랜잭션 고려</td> <td>가능하다면 조회 쿼리는 락을 걸지 않음</td> </tr> <tr> <td>비관적 락</td> <td><code class="language-plaintext highlighter-rouge">SELECT ... FOR UPDATE</code> → 락 걸린 상태로 트랜잭션 보장 (동시 수정 우려가 클 때)</td> </tr> <tr> <td>낙관적 락</td> <td>버전/타임스탬프로 변경 감지 → 충돌 시 롤백 유도 (충돌이 드물 때)</td> </tr> <tr> <td>파티셔닝 고려</td> <td>핫스팟 테이블은 파티션 설계</td> </tr> <tr> <td>인덱스 설계</td> <td>불필요한 테이블 락 유발 방지</td> </tr> <tr> <td>타임아웃 설정</td> <td>일정 시간이 지났는데도 작업이 완료되지 않으면 강제로 중단</td> </tr> </tbody> </table></div><hr /> <p><a href="https://www.yes24.com/product/search?query=%25EC%25B9%259C%25EC%25A0%2588%25ED%2595%259CSQL%25ED%258A%259C%25EB%258B%259D">친절한SQL튜닝</a></p> <p>https://escapefromcoding.tistory.com/777</p> <p><a href="https://bommbom.tistory.com/entry/ROWID%EC%99%80-%ED%81%B4%EB%A6%AC%EC%8A%A4%ED%84%B0%EB%A7%81-%ED%8C%A9%ED%84%B0CF%EC%9D%98-%EA%B4%80%EA%B3%84%EB%8A%94">https://bommbom.tistory.com/entry/ROWID와-클리스터링-팩터CF의-관계는</a></p> <p><a href="https://velog.io/@yooha9621/SQLP4%EC%9E%A5-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%99%80-%EC%A1%B0%EC%9D%B8-3.-%EC%A1%B0%EC%9D%B8-%EA%B8%B0%EB%B3%B8%EC%9B%90%EB%A6%AC">https://velog.io/@yooha9621/SQLP4장-인덱스와-조인-3.-조인-기본원리</a></p> <p>https://sabarada.tistory.com/175</p> </main> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
