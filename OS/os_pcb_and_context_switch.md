# PCB와 Context Switching

## PCB란?
운영체제는 컴퓨터 시스템에서 여러 프로세스를 관리해야 한다. 프로세스 제어 블록(PCB)는 운영체제가 각 프로세스에 대해 유지하는 데이터 구조로, 각 프로세스는 고유한 PCB를 가지며 현재 상태와 관련된 모든 정보를 저장한다.

PCB는 커널 영역에 생성되며, 프로세스가 생성될 때 할당되고, 프로세스가 종료될 때까지 유지된다.

![pcb_image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbRj8NW%2FbtsI9XtaVmg%2FXGHIy6sWX8H0jGQKDOtwqk%2Fimg.png)

### PCB에 저장되는 정보
1. **프로세스 상태 (Process State)**: 프로세스의 현재 상태. ex) 준비(Ready), 실행(Running), 대기(Waiting) 상태 등 
2. **프로세스 우선순위 (Scheduling Information)**: 프로세스의 우선순위, 스케줄링 큐 포인터 등 스케줄링과 관련된 정보
3. **프로그램 카운터 (Program Counter, PC)**: 다음에 실행될 명령어의 주소
4. **CPU 레지스터 (CPU Registers)**: 현재 프로세스가 사용하는 모든 CPU 레지스터의 값을 저장. 범용 레지스터, 데이터 레지스터, 세그먼트 레지스터 등이 포함됨
5. **소유자 정보 (Owner Information)**: 프로세스 소유자의 계정 정보와 CPU 사용 시간 등의 정보를 포함
6. **메모리 관리 정보 (Memory Management Information)**: 프로세스의 메모리 사용 정보를 포함. 페이지 테이블, 세그먼트 테이블, 메모리 경계 레지스터 등이 포함됨
7. **입출력 상태 정보 (I/O Status Information)**: 프로세스에 할당된 입출력 장치, 열린 파일 목록, 입출력 요청 등의 정보를 포함

### PCB의 사용 흐름
1. **프로세스 생성**: 새로운 프로세스가 생성될 때, 운영체제는 PCB를 생성하고, 프로세스에 대한 초기 정보를 저장한다.
2. **프로세스 실행**: 프로세스가 실행될 때, PCB는 현재 프로세스의 상태를 추적하고 필요한 정보를 제공한다.
3. **프로세스 일시 중지**: 프로세스가 일시중지되면, PCB는 프로세스의 현재 상태와 레지스터 값을 저장한다.
4. **프로세스의 재개**: 프로세스가 재개되면, PCB에 저장된 상태와 레지스터 값이 복원되어 프로세스가 계속 실행된다.
5. **프로세스 종료**: 프로세스가 종료되면, PCB는 운영체제에 의해 해제되고, 해당 자원은 다른 프로세스에게 할당된다.

## PCB와 연관

### 1. 인터럽트 (Interrupt)
인터럽트는 하드웨어나 소프트웨어에서 발생하는 이벤트로, CPU가 현재 작업을 일시 중지하고 즉각적인 처리가 필요한 작업을 수행하도록 한다.

인터럽트가 발생하면 현재 실행 중인 프로세스의 상태가 PCB에 저장되며, 인터럽트 서비스 루틴이 실행된다. 인터럽트 처리가 완료되면 PCB에서 상태를 복원해 프로세스가 계속 실행된다.

> 인터럽트 발생 시, 현재 프로세스의 상태(레지스터, 프로그램 카운터 등)가 PCB에 저장되고, 인터럽트 처리가 완료되면 PCB에서 상태가 복원된다. (컨텍스트 스위칭의 일환이다.)

### 2. 시스템 콜 (System Call)
사용자 프로그램이 운영체제의 커널 기능을 요청하는 것이다. 시스템 콜은 프로세스의 상태를 변경하거나, 자원 할당 등의 작업을 수행할 때 사용된다.

시스템 콜이 수행되면, PCB의 정보가 업데이트 되고, 필요 시 컨텍스트 스위칭이 발생할 수 있다.

> PCB와 시스템 콜: 시스템 콜 수행 중, 프로세스의 상태가 PCB에 저장되며, 커널 모드에서 필요한 작업이 수행된다. 작업 완료 후, PCB를 통해 프로세스 상태가 복원된다.

### 3. 스케줄링
CPU 시간을 여러 프로세스에게 효율적으로 분배하는 스케줄링은 어떤 프로세스가 언제 실행될지 결정한다.

- **PCB 큐**: 각 프로세스는 자신의 PCB를 가지고 있으며, 연결 리스트나 배열 형태로 저장하여, 프로세스의 상태와 스케줄링을 관리하는 데 사용한다.
- **컨텍스트 스위칭**: 스케줄러가 프로세스를 전환할 때, 현재 프로세스의 PCB를 저장하고, 새로운 프로세스의 PCB를 로드하여 실행한다.

## 컨텍스트 스위칭 (Context Switching)
컨텍스트 스위칭은 운영체제가 현재 실행 중인 프로세스의 상태를 저장하고, 새로운 프로세스의 상태를 복원하는 과정이다. 이를 통해 여러 프로세스가 CPU 시간을 공유하며 실행될 수 있다.

![Context Switching](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FLG6V0%2FbtsJ2caaMmf%2FZgYGB3SxWqTLpSIclj3Uk0%2Fimg.png)

### 컨텍스트 스위칭 과정
1. **현재 프로세스의 상태 저장**: CPU는 현재 실행 중인 프로세스의 상태(레지스터, 프로그램 카운터 등)를 PCB에 저장한다.
2. **새로운 프로세스의 PCB 로드**: 스케줄러는 다음 실행할 프로세스를 선택하고, 해당 프로세스의 PCB를 로드한다.
3. **새로운 프로세스의 상태 복원**: CPU는 새로운 프로세스의 상태를 PCB에서 복원한다.
4. **프로세스 실행 재개**: CPU는 프로그램 카운터가 가리키는 주소에서 새로운 프로세스의 명령어 실행을 시작한다.

### 컨텍스트 스위칭의 원인
1. **타임 슬라이스 종료**: 프로세스가 할당된 CPU 시간을 모두 사용한 경우
2. **I/O 요청**: 프로세스가 입출력 작업을 요청할 때
3. **시스템 콜**: 프로세스가 시스템 호출을 수행할 때
4. **인터럽트**: 하드웨어 인터럽트가 발생할 때

### 컨텍스트 스위칭의 문제점
1. **시간 오버헤드**: 프로세스 상태를 저장하고 복원하는 데 시간이 소요
2. **캐시 오버헤드**: CPU 캐시가 무효화되고 다시 로드되면서 성능 저하가 발생할 수 있음 (프로세스 컨텍스트 스위칭)
3. **복잡성 증가**: 잦은 컨텍스트 스위칭은 시스템의 복잡성을 증가시키고 관리하기 어려울 수 있음

## 컨텍스트 스위칭의 종류

### 프로세스 컨텍스트 스위칭 (Process Context Switching)
프로세스 컨텍스트 스위칭은 CPU가 현재 실행 중인 프로세스에서 다른 프로세스로 전환할 때 발생한다. 각 프로세스는 독립적인 메모리 주소 공간을 가지므로, 전환 시 많은 상태 정보를 저장하고 복원해야 한다.

#### 특징
1. **독립된 메모리 공간**: 각 프로세스는 자신의 독립된 주소 공간을 가지므로, 전환 시 주소 공간을 완전히 교체해야 한다.
2. **큰 오버헤드**: 메모리 매핑 정보, 페이지 테이블, 파일 디스크립터 등 많은 정보를 저장하고 복원해야 하므로 오버헤드가 크다.
3. **프로세스 독립성**: 프로세스는 서로 독립적이므로, 하나의 프로세스가 다른 프로세스의 메모리에 접근할 수 없다.

#### 과정
1. **현재 프로세스의 상태 저장**: 현재 프로세스의 레지스터, 프로그램 카운터, 메모리 매핑 정보 등을 PCB에 저장한다.
2. **새로운 프로세스의 PCB 로드**: 다음 실행할 프로세스의 PCB를 로드한다.
3. **새로운 프로세스의 상태 복원**: 새로운 프로세스의 레지스터, 프로그램 카운터, 메모리 매핑 정보 등을 복원한다.
4. **프로세스 실행 재개**: 프로그램 카운터가 가리키는 주소에서 새로운 프로세스의 실행을 시작한다.

#### 특징
1. **시간 오버헤드**: 프로세스 상태를 저장하고 복원하는 데 시간이 소요된다.
2. **캐시 오버헤드**: 프로세스 간 전환 시 CPU 캐시가 무효화되고, 새로운 프로세스의 데이터와 코드가 캐시에 로드되어야 하므로 성능 저하가 발생할 수 있다.
3. **복잡성 증가**: 잦은 프로세스 전환은 시스템의 복잡성을 증가시키고, 관리하기 어려울 수 있다.

### 스레드 컨텍스트 스위칭 (Thread Context Switching)
스레드 컨텍스트 스위칭은 동일한 프로세스 내에서 다른 스레드로 전환할 때 발생한다. 스레드는 프로세스 내에서 실행 흐름의 단위로, 동일한 주소 공간을 공유한다.

#### 특징
1. **공유된 메모리 공간**: 스레드는 같은 프로세스의 주소 공간을 공유하므로, 메모리 매핑 정보를 변경할 필요가 없다.
2. **작은 오버헤드**: 레지스터, 프로그램 카운터, 스택 포인터 등의 정보만 저장하고 복원하면 되므로 오버헤드가 작다.
3. **스레드 독립성**: 동일한 프로세스 내에서 스레드 간의 독립성을 보장하면서도 메모리 공간을 공유한다.

#### 과정
1. **현재 스레드의 상태 저장**: 현재 스레드의 레지스터, 프로그램 카운터 등을 스레드 컨트롤 블록(TCB)에 저장한다.
2. **새로운 스레드의 TCB 로드**: 다음 실행할 스레드의 TCB를 로드한다.
3. **새로운 스레드의 상태 복원**: 새로운 스레드의 레지스터, 프로그램 카운터 등을 복원한다.
4. **스레드 실행 재개**: 프로그램 카운터가 가리키는 주소에서 새로운 프로세스의 실행을 시작한다.

#### 특징
1. **동기화 문제**: 동일한 주소 공간을 공유하기 때문에 스레드 간의 데이터 접근 동기화가 필요하다.
2. **데이터 경쟁**: 적절한 동기화 메커니즘이 없으면 데이터 경쟁이 발생할 수 있다.
3. **캐시 오버헤드**: 상대적으로 적지만, 스레드 간의 데이터 접근 패턴 차이로 인해 일부 캐시 오버헤드가 발생할 수 있다.

## 컨텍스트 스위칭 비교

- **프로세스 컨텍스트 스위칭**은 큰 오버헤드와 캐시 무효화로 인한 성능 저하가 발생하지만, 프로세스 간의 독립성을 보장한다.
- **스레드 컨텍스트 스위칭**은 상대적으로 작은 오버헤드로 인해 효율적이지만, 동기화와 데이터 경쟁 문제가 발생할 수도 있다.

## 결론

PCB는 프로세스의 상태를 저장하고 관리하는 데이터 구조이며, 컨텍스트 스위칭은 이러한 PCB를 이용해 프로세스 간 전환을 수행하는 구체적인 과정이다.
